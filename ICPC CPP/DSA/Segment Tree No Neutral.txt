
class segment_tree {
public: 
    int size = 1;
    vector<int> tree;
    vector<int> leaves;

public:
    segment_tree(const vector<int>& elements) {
        size = 1 << (int) ceil(log2(elements.size()));
        tree.resize(size << 1);
        build(arr, 1, 0, n - 1);
    }

    int build(vector<int>& elements, int idx, int l, int r) {
        if (l == r) {
            tree[idx] = elements[l];
            leaves[l] = idx;
        } else {
            int mid = (l + r) / 2;
            int leftChild = build(elements, idx << 1, l, mid);
            int rightChild = build(elements, (idx << 1) | 1, mid + 1, r);
            tree[idx] = operation(leftChild, rightChild);
        }
        return tree[idx];
    }

    int operation(int a, int b) {
        return a + b;
    }

    int query(int l, int r) {
        return query(1, l, r, 0, size - 1);
    }

    int query(int currentIndex, int l, int r, int currentl, int currentr) {
        if (currentl >= l && currentr <= r) {
            return tree[currentIndex];
        }
        int mid = (currentl + currentr) >> 1;
        if (mid >= r) {
            return query(currentIndex << 1, l, r, currentl, mid);
        }
        if (mid < l) {
            return query(currentIndex << 1 | 1, l, r, mid + 1, currentr);
        }
        int leftChild = query(currentIndex << 1, l, r, currentl, mid);
        int rightChild = query(currentIndex << 1 | 1, l, r, mid + 1, currentr);
        return operation(leftChild, rightChild);
    }

    void set(int index, int val) {
        index = leaves[index];
        tree[index] = val;
        while (index > 1) {
            index >>= 1;
            tree[index] = tree[index << 1] + tree[index << 1 | 1];
        }
    }

    void add(int index, int val) {
        set(index, tree[leaves[index]] + val);
    }
};





    